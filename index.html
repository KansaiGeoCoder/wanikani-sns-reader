<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Âíå„Å´Kani - WaniKani SNS Learner</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.8s ease-out;
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .logo-icon {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .app-title {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            font-weight: 700;
            color: white;
            margin: 0;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .app-subtitle {
            color: rgba(255,255,255,0.9);
            font-size: 1rem;
            font-weight: 300;
            margin-top: 0.5rem;
        }

        .config-card {
            background: white;
            border-radius: 16px;
            padding: 2.5rem;
            max-width: 500px;
            margin: 0 auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            animation: fadeInUp 0.8s ease-out 0.2s both;
        }

        .config-title {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: #1a1a2e;
            font-weight: 500;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        .input-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #4a5568;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .api-input {
            width: 100%;
            padding: 0.875rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            font-family: monospace;
            transition: all 0.3s ease;
        }

        .api-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .submit-btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .submit-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .help-text {
            margin-top: 1rem;
            font-size: 0.85rem;
            color: #718096;
            line-height: 1.5;
        }

        .help-link {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .help-link:hover {
            text-decoration: underline;
        }

        .main-content {
            animation: fadeIn 0.6s ease-out;
        }

        .controls-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: white;
            padding: 1.5rem;
            border-radius: 16px;
            margin-bottom: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            gap: 1rem;
        }

        .level-selector {
            display: flex;
            align-items: center;
        }

        .level-select {
            padding: 0.5rem 2rem 0.5rem 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Noto Sans JP', sans-serif;
            font-weight: 500;
            cursor: pointer;
            background: white;
            transition: all 0.2s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%234a5568' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
        }

        .level-select:hover {
            border-color: #cbd5e0;
        }

        .level-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .legend-bar {
            background: white;
            padding: 1rem 1.5rem;
            border-radius: 16px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .legend-title {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.75rem;
            font-size: 0.9rem;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: #4a5568;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .vocab-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: #f7fafc;
            border-radius: 8px;
        }

        .vocab-meta-item {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .vocab-meta-label {
            font-size: 0.8rem;
            font-weight: 600;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .vocab-meta-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: #1a1a2e;
        }

        .vocab-meta-badge {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
        }

        .level-badge {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            font-weight: 600;
        }

        .refresh-btn, .settings-btn {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            background: #f7fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            font-family: 'Noto Sans JP', sans-serif;
            font-size: 1rem;
        }

        .refresh-btn:hover, .settings-btn:hover {
            background: #edf2f7;
            border-color: #cbd5e0;
        }

        .refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .refresh-btn:nth-of-type(2) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
        }

        .refresh-btn:nth-of-type(2):hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .posts-grid {
            display: grid;
            gap: 1.5rem;
        }

        .post-card {
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            animation: fadeInUp 0.5s ease-out both;
        }

        .post-card:nth-child(1) { animation-delay: 0.1s; }
        .post-card:nth-child(2) { animation-delay: 0.2s; }
        .post-card:nth-child(3) { animation-delay: 0.3s; }
        .post-card:nth-child(4) { animation-delay: 0.4s; }
        .post-card:nth-child(5) { animation-delay: 0.5s; }

        .post-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
        }

        .post-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .avatar {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .user-info {
            flex: 1;
        }

        .username {
            font-weight: 600;
            color: #1a1a2e;
            margin-bottom: 0.25rem;
        }

        .handle {
            color: #718096;
            font-size: 0.9rem;
        }

        .timestamp {
            color: #a0aec0;
            font-size: 0.85rem;
        }

        .post-content {
            font-size: 1.1rem;
            line-height: 1.8;
            color: #2d3748;
            margin-bottom: 1rem;
            font-weight: 400;
        }

        .knowledge-bar {
            width: 100%;
            height: 24px;
            background: #e2e8f0;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .knowledge-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #38a169 0%, #48bb78 50%, #68d391 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: width 0.5s ease;
            min-width: 50px;
        }

        .knowledge-text {
            color: white;
            font-size: 0.8rem;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .vocabulary-highlight {
            background: linear-gradient(120deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%);
            padding: 2px 4px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            border-bottom: 2px solid rgba(102, 126, 234, 0.3);
        }

        .vocabulary-highlight:hover {
            background: linear-gradient(120deg, rgba(102, 126, 234, 0.25) 0%, rgba(118, 75, 162, 0.25) 100%);
            border-bottom-color: rgba(102, 126, 234, 0.6);
        }

        .post-stats {
            display: flex;
            gap: 2rem;
            align-items: center;
            justify-content: space-between;
            padding-top: 1rem;
            border-top: 1px solid #e2e8f0;
            color: #718096;
            font-size: 0.9rem;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .source-link {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
            font-size: 0.9rem;
            transition: color 0.2s ease;
        }

        .source-link:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease-out;
            padding: 1rem;
        }

        .modal {
            background: white;
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: scaleIn 0.3s ease-out;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #1a1a2e;
        }

        .close-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            color: #718096;
            transition: color 0.2s ease;
        }

        .close-btn:hover {
            color: #1a1a2e;
        }

        .vocab-detail {
            margin-bottom: 1.5rem;
        }

        .vocab-character {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 1.5rem;
            color: #667eea;
        }

        .vocab-section {
            margin-bottom: 1.5rem;
        }

        .vocab-section-title {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .vocab-list {
            background: #f7fafc;
            padding: 1rem;
            border-radius: 8px;
            line-height: 1.8;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: white;
            font-size: 1.2rem;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 1rem;
            }

            .app-title {
                font-size: 2rem;
            }

            .controls-bar {
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }

            .refresh-btn, .settings-btn {
                width: 100%;
            }

            .level-selector {
                width: 100%;
                justify-content: space-between;
            }

            .level-select {
                flex: 1;
                max-width: 150px;
            }

            .legend-items {
                gap: 1rem;
            }

            .legend-item {
                font-size: 0.85rem;
            }

            .vocab-meta {
                grid-template-columns: 1fr;
            }

            .post-content {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <!-- Load React, ReactDOM, and Babel from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <script type="text/babel">
        const { useState, useEffect } = React;
        
        // Lucide icon components
        const Search = () => <i data-lucide="search"></i>;
        const BookOpen = () => <i data-lucide="book-open"></i>;
        const Sparkles = () => <i data-lucide="sparkles"></i>;
        const ExternalLink = ({ size, style }) => <i data-lucide="external-link" style={style}></i>;
        const Settings = () => <i data-lucide="settings"></i>;
        const X = () => <i data-lucide="x"></i>;
        const ChevronDown = () => <i data-lucide="chevron-down"></i>;

        const WaniKaniSNSLearner = () => {
            const [apiKey, setApiKey] = useState('');
            const [isConfigured, setIsConfigured] = useState(false);
            const [userLevel, setUserLevel] = useState(null);
            const [selectedLevel, setSelectedLevel] = useState(null);
            const [vocabulary, setVocabulary] = useState([]);
            const [assignments, setAssignments] = useState({});
            const [posts, setPosts] = useState([]);
            const [loading, setLoading] = useState(false);
            const [selectedWord, setSelectedWord] = useState(null);
            const [showSettings, setShowSettings] = useState(false);
            const [cachedContent, setCachedContent] = useState([]); // Cache fetched content

            useEffect(() => {
                // Initialize Lucide icons after component mounts/updates
                if (window.lucide) {
                    window.lucide.createIcons();
                }
            });

            const getSRSStage = (srsStage) => {
                if (srsStage === 9) return 'burned';
                if (srsStage >= 7) return 'enlightened';
                if (srsStage >= 6) return 'master';
                if (srsStage >= 5) return 'guru';
                if (srsStage >= 1) return 'apprentice';
                return 'new';
            };

            // Helper function to fetch all pages from WaniKani API
            const fetchAllPages = async (url, headers) => {
                let allData = [];
                let nextUrl = url;
                
                while (nextUrl) {
                    const response = await fetch(nextUrl, { headers });
                    if (!response.ok) throw new Error('API request failed');
                    
                    const data = await response.json();
                    allData = allData.concat(data.data);
                    
                    // Check if there's a next page
                    nextUrl = data.pages?.next_url;
                }
                
                return allData;
            };

            const fetchWaniKaniData = async (key) => {
                setLoading(true);
                try {
                    const headers = {
                        'Authorization': `Bearer ${key}`,
                        'Wanikani-Revision': '20170710'
                    };

                    // Fetch user information
                    const userResponse = await fetch('https://api.wanikani.com/v2/user', { headers });
                    
                    if (!userResponse.ok) throw new Error('Invalid API key');
                    
                    const userData = await userResponse.json();
                    const level = userData.data.level;
                    setUserLevel(level);
                    setSelectedLevel(level);

                    console.log('Fetching vocabulary for levels 1-' + level + '...');

                    // Fetch ALL vocabulary for all levels up to current (with pagination)
                    const levelRange = Array.from({length: level}, (_, i) => i + 1).join(',');
                    const vocabData = await fetchAllPages(
                        `https://api.wanikani.com/v2/subjects?types=vocabulary&levels=${levelRange}`,
                        headers
                    );
                    
                    console.log('Total vocabulary items fetched:', vocabData.length);

                    // Fetch ALL assignments to get SRS stages (with pagination)
                    const assignmentsData = await fetchAllPages(
                        'https://api.wanikani.com/v2/assignments?subject_types=vocabulary',
                        headers
                    );
                    
                    console.log('Total assignments fetched:', assignmentsData.length);
                    
                    // Create a map of subject_id to SRS stage
                    const assignmentsMap = {};
                    assignmentsData.forEach(assignment => {
                        assignmentsMap[assignment.data.subject_id] = {
                            srsStage: assignment.data.srs_stage,
                            stage: getSRSStage(assignment.data.srs_stage)
                        };
                    });

                    const vocabList = vocabData.map(item => ({
                        id: item.id,
                        characters: item.data.characters,
                        meanings: item.data.meanings.map(m => m.meaning),
                        readings: item.data.readings.map(r => r.reading),
                        level: item.data.level,
                        srsStage: assignmentsMap[item.id]?.srsStage || 0,
                        stage: assignmentsMap[item.id]?.stage || 'new'
                    }));

                    setVocabulary(vocabList);
                    setAssignments(assignmentsMap);
                    setIsConfigured(true);
                    
                    fetchRealContent(vocabList, level);
                } catch (error) {
                    alert('Error fetching WaniKani data. Please check your API key.');
                    console.error(error);
                } finally {
                    setLoading(false);
                }
            };

            // Fetch real Japanese content from various sources
            const fetchRealContent = async (vocabList, targetLevel) => {
                setLoading(true);
                const allContent = [];

                try {
                    console.log('Fetching Japanese content...');
                    
                    // Fetch from NHK News Easy (using CORS proxy)
                    try {
                        console.log('Fetching NHK News Easy...');
                        const nhkResponse = await fetch('https://corsproxy.io/?https://www3.nhk.or.jp/news/easy/news-list.json');
                        const nhkData = await nhkResponse.json();
                        
                        const articles = nhkData[0]?.list || [];
                        console.log('Found', articles.length, 'NHK articles');
                        
                        // Helper function to validate content quality
                        const isValidSentence = (text) => {
                            // Must have Japanese characters
                            const japaneseChars = (text.match(/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g) || []).length;
                            if (japaneseChars < 10) return false;
                            
                            // Check length
                            if (text.length < 15 || text.length > 120) return false;
                            
                            // Filter out navigation/UI text
                            if (text.includes('„Éã„É•„Éº„Çπ') && text.length < 20) return false;
                            if (text.includes('Ë®ò‰∫ã') && text.length < 20) return false;
                            if (text.includes('Ë©≥„Åó„Åè') && text.length < 20) return false;
                            
                            // Must not be mostly punctuation
                            const punctuation = (text.match(/[„ÄÅ„ÄÇÔºÅÔºü„Äå„Äç„Äé„ÄèÔºàÔºâ]/g) || []).length;
                            if (punctuation > text.length / 3) return false;
                            
                            return true;
                        };
                        
                        for (const article of articles.slice(0, 30)) {
                            try {
                                const articleResponse = await fetch(`https://corsproxy.io/?https://www3.nhk.or.jp/news/easy/${article.news_id}/${article.news_id}.html`);
                                const html = await articleResponse.text();
                                
                                const parser = new DOMParser();
                                const doc = parser.parseFromString(html, 'text/html');
                                
                                // Get article body paragraphs (skip navigation and headers)
                                const articleBody = doc.querySelector('#js-article-body');
                                if (!articleBody) continue;
                                
                                const paragraphs = articleBody.querySelectorAll('p');
                                
                                paragraphs.forEach(p => {
                                    const text = p.textContent.trim();
                                    
                                    // Split into sentences
                                    const sentences = text.split(/[„ÄÇÔºÅÔºü]/);
                                    sentences.forEach(sentence => {
                                        const cleaned = sentence.trim();
                                        
                                        if (isValidSentence(cleaned)) {
                                            allContent.push({
                                                text: cleaned + '„ÄÇ',
                                                source: 'NHK News Easy',
                                                sourceIcon: 'üì∞',
                                                title: article.title,
                                                url: `https://www3.nhk.or.jp/news/easy/${article.news_id}/${article.news_id}.html`
                                            });
                                        }
                                    });
                                });
                            } catch (e) {
                                console.log('Error fetching NHK article:', e);
                            }
                        }
                        console.log('NHK content extracted:', allContent.length);
                    } catch (e) {
                        console.log('Error fetching NHK news:', e);
                    }

                    // Fetch from Reddit (Japanese subreddits)
                    try {
                        console.log('Fetching Reddit content...');
                        const subreddits = ['newsokur', 'japan_anime', 'newsokuexp', 'BakaNewsJP'];
                        
                        // Helper function to check if text is good quality
                        const isGoodContent = (text) => {
                            // Must have Japanese characters
                            if (!/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/.test(text)) return false;
                            
                            // Must have reasonable length
                            if (text.length < 15 || text.length > 120) return false;
                            
                            // Filter out markdown links and formatting
                            if (text.includes('[') || text.includes(']') || text.includes('**')) return false;
                            if (text.includes('http') || text.includes('www.')) return false;
                            
                            // Filter out content that's mostly punctuation
                            const japaneseChars = (text.match(/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g) || []).length;
                            if (japaneseChars < 10) return false;
                            
                            // Filter out lines that look like headers or wiki content
                            if (text.startsWith('##') || text.startsWith('###')) return false;
                            if (text.includes('wiki/') || text.includes('FAQ')) return false;
                            
                            return true;
                        };
                        
                        for (const subreddit of subreddits) {
                            try {
                                const redditResponse = await fetch(`https://www.reddit.com/r/${subreddit}.json?limit=50`);
                                const redditData = await redditResponse.json();
                                
                                redditData.data.children.forEach(post => {
                                    const title = post.data.title;
                                    const selftext = post.data.selftext;
                                    
                                    // Only process actual posts, not stickied announcements
                                    if (post.data.stickied) return;
                                    
                                    // Check title
                                    if (isGoodContent(title)) {
                                        allContent.push({
                                            text: title,
                                            source: `r/${subreddit}`,
                                            sourceIcon: 'üí¨',
                                            title: post.data.author,
                                            url: `https://www.reddit.com${post.data.permalink}`
                                        });
                                    }
                                    
                                    // Check self text
                                    if (selftext && selftext.length > 20) {
                                        const sentences = selftext.split(/[„ÄÇÔºÅÔºü\n]/);
                                        sentences.forEach(sentence => {
                                            const cleaned = sentence.trim();
                                            if (isGoodContent(cleaned)) {
                                                allContent.push({
                                                    text: cleaned + '„ÄÇ',
                                                    source: `r/${subreddit}`,
                                                    sourceIcon: 'üí¨',
                                                    title: post.data.author,
                                                    url: `https://www.reddit.com${post.data.permalink}`
                                                });
                                            }
                                        });
                                    }
                                });
                            } catch (e) {
                                console.log(`Error fetching r/${subreddit}:`, e);
                            }
                        }
                        console.log('Total content after Reddit:', allContent.length);
                    } catch (e) {
                        console.log('Error fetching Reddit:', e);
                    }

                    console.log('Total content collected:', allContent.length);

                    if (allContent.length === 0) {
                        console.log('No content fetched. This might be due to CORS restrictions or API issues.');
                        alert('Unable to fetch Japanese content. This may be due to browser security restrictions (CORS) or the content sources being temporarily unavailable. Please try refreshing.');
                    }

                    // Final validation - filter out any bad content that slipped through
                    const validatedContent = allContent.filter(item => {
                        // No markdown or special formatting
                        if (item.text.includes('[') || item.text.includes(']')) return false;
                        if (item.text.includes('**') || item.text.includes('##')) return false;
                        if (item.text.includes('http') || item.text.includes('www.')) return false;
                        
                        // Must have reasonable Japanese content
                        const japaneseChars = (item.text.match(/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g) || []).length;
                        if (japaneseChars < 8) return false;
                        
                        // Not too short or too long
                        if (item.text.length < 12 || item.text.length > 150) return false;
                        
                        return true;
                    });
                    
                    console.log('After validation:', validatedContent.length, 'sentences');

                    // Cache the validated content for future refreshes
                    setCachedContent(validatedContent);

                    // Match sentences with vocabulary
                    const filteredVocab = vocabList.filter(v => v.level <= targetLevel);
                    console.log('Matching against', filteredVocab.length, 'vocabulary items');
                    
                    const matchedPosts = matchSentencesWithVocab(validatedContent, filteredVocab);
                    console.log('Found', matchedPosts.length, 'matched sentences');
                    
                    if (matchedPosts.length === 0 && validatedContent.length > 0) {
                        alert('Content was fetched but no sentences matched your vocabulary well. Try a different level or refresh for new content.');
                    } else if (matchedPosts.length < 5) {
                        console.log('Warning: Only found', matchedPosts.length, 'good matches. You may want to refresh for more content.');
                    }
                    
                    // Shuffle the matched posts to show different content on each refresh
                    const shuffled = [...matchedPosts].sort(() => Math.random() - 0.5);
                    setPosts(shuffled.slice(0, 15)); // Show 15 random matches from the pool
                } catch (error) {
                    console.error('Error fetching content:', error);
                    alert('Error fetching Japanese content. Please try again. Check the browser console for details.');
                } finally {
                    setLoading(false);
                }
            };

            // Match sentences with user's vocabulary - improved algorithm with better compound word handling
            const matchSentencesWithVocab = (contentArray, vocabList) => {
                // Score each sentence based on vocabulary matches
                const scoredContent = contentArray.map(content => {
                    const matches = [];
                    const matchedPositions = new Set();
                    
                    // Create a list of all possible matches with their positions
                    const possibleMatches = [];
                    vocabList.forEach(vocab => {
                        let searchPos = 0;
                        while (true) {
                            const index = content.text.indexOf(vocab.characters, searchPos);
                            if (index === -1) break;
                            
                            possibleMatches.push({
                                vocab: vocab,
                                position: index,
                                length: vocab.characters.length
                            });
                            
                            searchPos = index + 1;
                        }
                    });
                    
                    // Sort by position first, then by length (longest first) for same position
                    possibleMatches.sort((a, b) => {
                        if (a.position !== b.position) {
                            return a.position - b.position;
                        }
                        return b.length - a.length; // Longer words first at same position
                    });
                    
                    // Select non-overlapping matches, preferring longer words
                    possibleMatches.forEach(match => {
                        // Check if any position in this match is already taken
                        let hasOverlap = false;
                        for (let i = match.position; i < match.position + match.length; i++) {
                            if (matchedPositions.has(i)) {
                                hasOverlap = true;
                                break;
                            }
                        }
                        
                        if (!hasOverlap) {
                            // Mark all positions as used
                            for (let i = match.position; i < match.position + match.length; i++) {
                                matchedPositions.add(i);
                            }
                            
                            matches.push({
                                ...match.vocab,
                                position: match.position
                            });
                        }
                    });
                    
                    // Calculate total matched character count
                    const totalKnownChars = matches.reduce((sum, m) => sum + m.characters.length, 0);
                    
                    // Count Japanese characters in the sentence
                    const japaneseChars = (content.text.match(/[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g) || []).length;
                    
                    // Calculate percentage of known content
                    const knownPercentage = japaneseChars > 0 ? (totalKnownChars / japaneseChars) * 100 : 0;
                    
                    // Calculate score
                    const matchCount = matches.length;
                    const lengthPenalty = Math.max(0, 100 - content.text.length) / 100;
                    const score = (knownPercentage * 10) + (matchCount * 5) + lengthPenalty;
                    
                    return {
                        ...content,
                        vocabulary: matches,
                        matchCount,
                        knownPercentage,
                        score
                    };
                });
                
                // Filter to sentences with at least 40% known vocabulary and sort by score
                return scoredContent
                    .filter(c => c.knownPercentage >= 40 && c.matchCount > 0)
                    .sort((a, b) => b.score - a.score)
                    .map(content => ({
                        username: content.source,
                        handle: content.title,
                        avatar: content.sourceIcon,
                        timestamp: 'Recent',
                        finalContent: content.text,
                        vocabulary: content.vocabulary,
                        likes: content.matchCount,
                        retweets: Math.round(content.knownPercentage),
                        sourceUrl: content.url,
                        knownPercentage: content.knownPercentage
                    }));
            };

            const handleConfigSubmit = (e) => {
                e.preventDefault();
                if (apiKey.trim()) {
                    fetchWaniKaniData(apiKey.trim());
                }
            };

            const refreshPosts = () => {
                if (vocabulary.length > 0) {
                    // If we have cached content, use it for instant refresh
                    if (cachedContent.length > 0) {
                        console.log('Using cached content for refresh');
                        const filteredVocab = vocabulary.filter(v => v.level <= selectedLevel);
                        const matchedPosts = matchSentencesWithVocab(cachedContent, filteredVocab);
                        
                        // Shuffle to show different sentences
                        const shuffled = [...matchedPosts].sort(() => Math.random() - 0.5);
                        setPosts(shuffled.slice(0, 15));
                    } else {
                        // No cache, fetch fresh content
                        fetchRealContent(vocabulary, selectedLevel);
                    }
                }
            };
            
            const forceRefreshContent = () => {
                // Clear cache and fetch fresh content
                if (vocabulary.length > 0) {
                    console.log('Force refreshing content...');
                    setCachedContent([]);
                    fetchRealContent(vocabulary, selectedLevel);
                }
            };

            const handleLevelChange = (newLevel) => {
                setSelectedLevel(newLevel);
                fetchRealContent(vocabulary, newLevel);
            };

            const getStageColor = (stage) => {
                switch(stage) {
                    case 'burned': return '#4a5568';
                    case 'enlightened': return '#805ad5';
                    case 'master': return '#3182ce';
                    case 'guru': return '#38a169';
                    case 'apprentice': return '#dd6b20';
                    default: return '#e53e3e';
                }
            };

            const getStageLabel = (stage) => {
                switch(stage) {
                    case 'burned': return 'üî• Burned';
                    case 'enlightened': return '‚ú® Enlightened';
                    case 'master': return 'üéì Master';
                    case 'guru': return 'üåü Guru';
                    case 'apprentice': return 'üìù Apprentice';
                    default: return 'üÜï New';
                }
            };

            const highlightVocabulary = (content, vocabList) => {
                // Sort vocabulary by position to highlight in order
                const sortedVocab = [...vocabList].sort((a, b) => a.position - b.position);
                
                let result = [];
                let lastIndex = 0;
                
                sortedVocab.forEach((vocab, idx) => {
                    const position = vocab.position;
                    
                    // Add text before this vocabulary word
                    if (position > lastIndex) {
                        result.push(
                            <span key={`text-${idx}`}>{content.slice(lastIndex, position)}</span>
                        );
                    }
                    
                    // Add highlighted vocabulary
                    const stageColor = getStageColor(vocab.stage);
                    result.push(
                        <span
                            key={`vocab-${idx}-${position}`}
                            className="vocabulary-highlight"
                            onClick={() => setSelectedWord(vocab)}
                            style={{
                                borderBottomColor: stageColor,
                                background: `linear-gradient(120deg, ${stageColor}15 0%, ${stageColor}25 100%)`
                            }}
                            title={getStageLabel(vocab.stage)}
                        >
                            {vocab.characters}
                        </span>
                    );
                    
                    lastIndex = position + vocab.characters.length;
                });
                
                // Add remaining text after last vocabulary word
                if (lastIndex < content.length) {
                    result.push(
                        <span key="text-end">{content.slice(lastIndex)}</span>
                    );
                }
                
                return result;
            };

            return (
                <div className="app-container">
                    <div className="header">
                        <div className="logo">
                            <div className="logo-icon">üéå</div>
                            <h1 className="app-title">Âíå„Å´Kani</h1>
                        </div>
                        <p className="app-subtitle">Learn Japanese through real-world social media content</p>
                    </div>

                    {!isConfigured ? (
                        <div className="config-card">
                            <h2 className="config-title">Connect Your WaniKani Account</h2>
                            <form onSubmit={handleConfigSubmit}>
                                <div className="input-group">
                                    <label className="input-label">WaniKani API Key</label>
                                    <input
                                        type="password"
                                        className="api-input"
                                        value={apiKey}
                                        onChange={(e) => setApiKey(e.target.value)}
                                        placeholder="Enter your WaniKani API v2 token"
                                        disabled={loading}
                                    />
                                </div>
                                <button type="submit" className="submit-btn" disabled={loading || !apiKey.trim()}>
                                    {loading ? 'Connecting...' : 'Start Learning'}
                                </button>
                                <p className="help-text">
                                    Get your API key from{' '}
                                    <a 
                                        href="https://www.wanikani.com/settings/personal_access_tokens" 
                                        target="_blank" 
                                        rel="noopener noreferrer"
                                        className="help-link"
                                    >
                                        WaniKani Settings <ExternalLink size={14} style={{ display: 'inline', verticalAlign: 'middle' }} />
                                    </a>
                                </p>
                            </form>
                        </div>
                    ) : (
                        <div className="main-content">
                            <div className="controls-bar">
                                <div className="level-badge">
                                    <BookOpen />
                                    <span>Level {userLevel}</span>
                                </div>
                                
                                <div className="level-selector">
                                    <label style={{ marginRight: '0.5rem', color: '#4a5568', fontWeight: '500' }}>
                                        Study Level:
                                    </label>
                                    <select 
                                        value={selectedLevel} 
                                        onChange={(e) => handleLevelChange(parseInt(e.target.value))}
                                        className="level-select"
                                    >
                                        {Array.from({length: userLevel}, (_, i) => i + 1).map(level => (
                                            <option key={level} value={level}>
                                                Level {level}
                                            </option>
                                        ))}
                                    </select>
                                </div>

                                <button 
                                    className="refresh-btn" 
                                    onClick={refreshPosts}
                                    title="Show different sentences from the current content pool"
                                >
                                    <Sparkles />
                                    Shuffle
                                </button>
                                <button 
                                    className="refresh-btn" 
                                    onClick={forceRefreshContent}
                                    title="Fetch fresh content from NHK and Reddit (takes ~20 seconds)"
                                    disabled={loading}
                                >
                                    <Search />
                                    {loading ? 'Loading...' : 'Fetch Fresh'}
                                </button>
                                <button className="settings-btn" onClick={() => setShowSettings(true)}>
                                    <Settings />
                                    Settings
                                </button>
                            </div>

                            <div className="legend-bar">
                                <div className="legend-title">SRS Stages:</div>
                                <div className="legend-items">
                                    <div className="legend-item">
                                        <span className="legend-dot" style={{background: getStageColor('new')}}></span>
                                        <span>New</span>
                                    </div>
                                    <div className="legend-item">
                                        <span className="legend-dot" style={{background: getStageColor('apprentice')}}></span>
                                        <span>Apprentice</span>
                                    </div>
                                    <div className="legend-item">
                                        <span className="legend-dot" style={{background: getStageColor('guru')}}></span>
                                        <span>Guru</span>
                                    </div>
                                    <div className="legend-item">
                                        <span className="legend-dot" style={{background: getStageColor('master')}}></span>
                                        <span>Master</span>
                                    </div>
                                    <div className="legend-item">
                                        <span className="legend-dot" style={{background: getStageColor('enlightened')}}></span>
                                        <span>Enlightened</span>
                                    </div>
                                    <div className="legend-item">
                                        <span className="legend-dot" style={{background: getStageColor('burned')}}></span>
                                        <span>Burned</span>
                                    </div>
                                </div>
                            </div>

                            <div className="posts-grid">
                                {loading ? (
                                    <div className="loading">Loading Japanese content...</div>
                                ) : posts.length === 0 ? (
                                    <div className="loading">No content found. Try refreshing or selecting a different level.</div>
                                ) : (
                                    posts.map((post, idx) => (
                                        <div key={idx} className="post-card">
                                            <div className="post-header">
                                                <div className="avatar">{post.avatar}</div>
                                                <div className="user-info">
                                                    <div className="username">{post.username}</div>
                                                    <div className="handle">{post.handle}</div>
                                                </div>
                                                <div className="timestamp">{post.timestamp}</div>
                                            </div>
                                            <div className="post-content">
                                                {highlightVocabulary(post.finalContent, post.vocabulary)}
                                            </div>
                                            <div className="knowledge-bar">
                                                <div className="knowledge-bar-fill" style={{ width: `${post.retweets}%` }}>
                                                    <span className="knowledge-text">{post.retweets}% known</span>
                                                </div>
                                            </div>
                                            <div className="post-stats">
                                                <div className="stat" title="Number of your vocabulary words in this sentence">
                                                    <span>üìö</span>
                                                    <span>{post.likes} {post.likes === 1 ? 'word' : 'words'}</span>
                                                </div>
                                                {post.sourceUrl && (
                                                    <a 
                                                        href={post.sourceUrl} 
                                                        target="_blank" 
                                                        rel="noopener noreferrer"
                                                        className="source-link"
                                                    >
                                                        View Source ‚Üí
                                                    </a>
                                                )}
                                            </div>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>
                    )}

                    {selectedWord && (
                        <div className="modal-overlay" onClick={() => setSelectedWord(null)}>
                            <div className="modal" onClick={(e) => e.stopPropagation()}>
                                <div className="modal-header">
                                    <h3 className="modal-title">Vocabulary</h3>
                                    <button className="close-btn" onClick={() => setSelectedWord(null)}>
                                        <X />
                                    </button>
                                </div>
                                <div className="vocab-detail">
                                    <div className="vocab-character">{selectedWord.characters}</div>
                                    
                                    <div className="vocab-meta">
                                        <div className="vocab-meta-item">
                                            <span className="vocab-meta-label">Level:</span>
                                            <span className="vocab-meta-value">{selectedWord.level}</span>
                                        </div>
                                        <div className="vocab-meta-item">
                                            <span className="vocab-meta-label">SRS Stage:</span>
                                            <span 
                                                className="vocab-meta-badge"
                                                style={{
                                                    background: getStageColor(selectedWord.stage),
                                                    color: 'white'
                                                }}
                                            >
                                                {getStageLabel(selectedWord.stage)}
                                            </span>
                                        </div>
                                    </div>

                                    <div className="vocab-section">
                                        <div className="vocab-section-title">Meanings</div>
                                        <div className="vocab-list">
                                            {selectedWord.meanings.join(', ')}
                                        </div>
                                    </div>
                                    <div className="vocab-section">
                                        <div className="vocab-section-title">Readings</div>
                                        <div className="vocab-list">
                                            {selectedWord.readings.join(', ')}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {showSettings && (
                        <div className="modal-overlay" onClick={() => setShowSettings(false)}>
                            <div className="modal" onClick={(e) => e.stopPropagation()}>
                                <div className="modal-header">
                                    <h3 className="modal-title">Settings</h3>
                                    <button className="close-btn" onClick={() => setShowSettings(false)}>
                                        <X />
                                    </button>
                                </div>
                                <div className="vocab-section">
                                    <div className="vocab-section-title">Current Level</div>
                                    <div className="vocab-list">Level {userLevel}</div>
                                </div>
                                <div className="vocab-section">
                                    <div className="vocab-section-title">Study Level</div>
                                    <div className="vocab-list">Level {selectedLevel}</div>
                                </div>
                                <div className="vocab-section">
                                    <div className="vocab-section-title">Vocabulary Statistics</div>
                                    <div className="vocab-list">
                                        <div style={{ marginBottom: '0.5rem' }}>
                                            Total: {vocabulary.filter(v => v.level <= selectedLevel).length} words (up to level {selectedLevel})
                                        </div>
                                        <div style={{ display: 'grid', gap: '0.5rem', marginTop: '1rem' }}>
                                            {['burned', 'enlightened', 'master', 'guru', 'apprentice', 'new'].map(stage => {
                                                const count = vocabulary.filter(v => v.level <= selectedLevel && v.stage === stage).length;
                                                if (count === 0) return null;
                                                return (
                                                    <div key={stage} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
                                                        <span 
                                                            style={{ 
                                                                width: '10px', 
                                                                height: '10px', 
                                                                borderRadius: '50%', 
                                                                background: getStageColor(stage),
                                                                display: 'inline-block'
                                                            }}
                                                        ></span>
                                                        <span style={{ textTransform: 'capitalize' }}>{stage}:</span>
                                                        <span style={{ fontWeight: '600' }}>{count}</span>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                                <button 
                                    className="submit-btn" 
                                    onClick={() => {
                                        setIsConfigured(false);
                                        setShowSettings(false);
                                        setApiKey('');
                                    }}
                                    style={{ marginTop: '1rem' }}
                                >
                                    Change API Key
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Render the app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WaniKaniSNSLearner />);
    </script>
</body>
</html>
